Source URL: https://developers.google.com/maps/documentation/geocoding/web-service-best-practices?hl=ko
Title: Geocoding API 웹 서비스 사용 시 권장사항

의견 보내기

Geocoding API 웹 서비스 사용 시 권장사항

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

Google Maps Platform 웹 서비스는 지도 애플리케이션에 지리적 데이터를 제공하는 Google 서비스에 대한 HTTP 인터페이스 모음입니다.

이 가이드에서는 웹 서비스 요청을 설정하고 서비스 응답을 처리하는 데 유용한 몇 가지 일반적인 관행을 설명합니다. Geocoding API에 관한 전체 문서는 개발자 가이드 [https://developers.google.com/maps/documentation/geocoding/overview?hl=ko]를 참고하세요.

웹 서비스란 무엇인가요?

Google Maps Platform 웹 서비스는 외부 서비스에서 Maps API 데이터를 요청하고 지도 애플리케이션 내에서 데이터를 사용하는 인터페이스입니다. 이러한 서비스는 Google Maps Platform 서비스 약관의 라이선스 제한 [https://cloud.google.com/maps-platform/terms/?hl=ko#3.-license.]에 따라 지도와 함께 사용하도록 설계되었습니다.

Maps API 웹 서비스는 특정 URL에 대한 HTTP(S) 요청을 사용하여 URL 매개변수 또는 JSON 형식의 POST 데이터를 서비스에 인수로 전달합니다. 일반적으로 이러한 서비스는 애플리케이션에서 파싱하거나 처리할 수 있도록 응답 본문의 데이터를 JSON 또는 XML로 반환합니다.

일반적인 Geocoding API 요청은 일반적으로 다음과 같은 형식입니다.

https://maps.googleapis.com/maps/api/geocode/output?parameters

여기서 output는 응답 형식 (일반적으로 json 또는 xml)을 나타냅니다.

참고: 모든 Geocoding API 애플리케이션에는 인증이 필요합니다.
인증 사용자 인증 정보 [https://developers.google.com/maps/documentation/geocoding/get-api-key?hl=ko]에 대해 자세히 알아보세요.

SSL/TLS 액세스
API 키를 사용하거나 사용자 데이터를 포함하는 모든 Google Maps Platform 요청에는 HTTPS가 필요합니다. 민감한 정보가 포함된 HTTP를 통한 요청은 거부될 수 있습니다.

올바른 URL 작성

'유효한' URL은 그 자체로 충분할 것 같지만 실제로는 그렇지 않습니다. 예를 들어 브라우저의 주소 표시줄에 입력된 URL은 특수문자(예: "上海+中國")를 포함할 수 있고, 이 경우 브라우저는 이러한 문자를 전송하기 전에 내부적으로 다른 인코딩으로 변환해야 합니다.
마찬가지로 UTF-8 입력을 생성하거나 수락하는 코드는 UTF-8 문자가 있는 URL을 '유효한' 것으로 취급할 수 있지만 그러한 문자를 웹 서버로 보내기 전에 변환해야 합니다.
이 과정을 URL 인코딩 [https://en.wikipedia.org/wiki/Query_string#URL_encoding] 또는 퍼센트 인코딩 [https://en.wikipedia.org/wiki/Percent-encoding]이라고 합니다.

주의: 브라우저 또는 서비스는 전송하기 전에 요청 URI를 자동으로 URL 인코딩할 수 있습니다. 암호화 요청 서명을 사용하는 API에서는 URL 인코딩이 서명 후에 요청을 변경하면 서명이 무효화될 수 있습니다. 이 문제를 방지하려면 요청에 서명하기 전에 항상 쿼리 문자열을 URL 인코딩합니다.

특수문자
모든 URL은 URI(Uniform Resource Identifier) [http://tools.ietf.org/html/rfc3986] 사양에서 지정된 구문을 준수해야 하므로 특수문자는 변환해야 합니다. 실제로 URL에는 ASCII 문자 중 일부 특수한 문자(예: 익히 알고 있는 영숫자 기호, URL 내에서 제어 문자로 사용하기 위해 예약된 일부 문자)만 포함되어야 합니다. 다음 표에 이러한 문자가 요약되어 있습니다.

올바른 URL 문자 요약| 세트 | 문자 | URL 사용 |
| --- | --- | --- |
| 영숫자 | a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 0 1 2 3 4 5 6 7 8 9 | 텍스트 문자열, 스킴 사용(http), 포트(8080) 등 |
| 예약되지 않음 | - _ . ~ | 텍스트 문자열 |
| 예약됨 | ! * ' ( ) ; : @ & = + $ , / ? % # [ ] | 제어 문자 또는 텍스트 문자열 |

유효한 URL을 작성할 때는 표에 표시된 문자만 사용해야 합니다. 이러한 문자 집합을 사용하여 URL을 작성하다 보면 일반적으로 다음과 같이 누락과 대체라는 두 가지 문제가 발생합니다.

처리하려는 문자가 위의 집합에 없는 경우. 예를 들어 上海+中國 등의 외국어 문자는 위의 문자를 사용하여 인코딩해야 합니다. 관례적으로 URL 내에서 허용되지 않는 공백은 더하기 문자('+')를 사용해서 표현하기도 합니다.
예약된 문자로 위 집합에 포함된 문자를 문자 그대로 사용해야 하는 경우.
예를 들어 ?는 URL 내에서 쿼리 문자열의 시작을 나타내는 데 사용되는데, '? and the Mysterions'라는 문자열을 사용하려면 '?' 문자를 인코딩해야 합니다.

URL 인코딩이 필요한 모든 문자는 '%' 문자 및 UTF-8 문자에 해당하는 2자리 16진수 값을 사용하여 인코딩됩니다. 예를 들어 UTF-8 형식의 上海+中國은 %E4%B8%8A%E6%B5%B7%2B%E4%B8%AD%E5%9C%8B로 URL 인코딩됩니다. ? and the Mysterians 문자열은 %3F+and+the+Mysterians 또는 %3F%20and%20the%20Mysterians로 URL 인코딩됩니다.

인코딩이 필요한 일반 문자
일부 일반 문자는 다음과 같이 인코딩되어야 합니다.

| 안전하지 않은 문자 | 인코딩된 값 |
| --- | --- |
| 공백 | %20 |
| " | %22 |
| < | %3C |
| > | %3E |
| # | %23 |
| % | %25 |
| \| | %7C |

때로는 사용자가 입력한 URL을 수신하여 변환하는 과정이 까다로울 수 있습니다. 예를 들어 사용자가 주소를 '5th&Main St.'로 입력할 수 있습니다.
일반적으로 URL은 해당 부분을 사용하여 구성해야 하므로 모든 사용자 입력은 리터럴 문자로 취급해야 합니다.

또한 URL은 모든 Google Maps Platform 웹 서비스 및 정적 웹 API에서 16, 384자(영문 기준)로 제한됩니다. 대부분의 서비스에서는 이러한 글자 수 제한에 도달하는 일이 거의 없습니다. 그러나 URL을 길게 만드는 매개변수가 포함된 서비스도 있습니다.

적절한 Google API 사용

설계가 잘못된 API 클라이언트는 인터넷과 Google 서버에 필요 이상으로 많은 부하를 줄 수 있습니다.  이 섹션에는 API 클라이언트의 모범 사례가 포함되어 있습니다. 이러한 권장사항을 따르면 API를 의도치 않게 악용하여 애플리케이션이 차단되는 것을 방지할 수 있습니다.

오류 및 재시도 관리

Geocoding API의 UNKNOWN_ERROR 또는 OVER_QUERY_LIMIT 응답 코드에 관한 자세한 내용은 오류 및 재시도 관리 [https://developers.google.com/maps/documentation/geocoding/best-practices?hl=ko#managing-errors]를 참고하세요.

지수 백오프

드물지만 요청을 처리하는 중에 문제가 발생할 수 있습니다. 4XX 또는 5XX HTTP 응답 코드가 수신되거나 클라이언트와 Google 서버 간에 TCP 연결이 실패할 수 있습니다. 원래 요청이 실패한 경우 후속 요청이 성공할 수 있으므로 요청을 다시 시도하는 것이 좋습니다. 하지만 Google 서버에 반복적으로 요청을 반복하지 않는 것이 중요합니다. 이러한 루핑 동작은 클라이언트와 Google 간의 네트워크에 과부하를 일으켜 여러 당사자에게 문제가 발생할 수 있습니다.

따라서 시도 사이의 지연 시간을 늘려 재시도하는 것이 훨씬 좋습니다. 일반적으로 지연은 시도할 때마다 배수로 증가하며 이를 지수 백오프 [https://en.wikipedia.org/wiki/Exponential_backoff]라고 합니다.

예를 들어 Time Zone API에 다음과 같은 요청을 하고자 하는 애플리케이션을 생각해 보겠습니다.
https://maps.googleapis.com/maps/api/timezone/json?location=39.6034810,-119.6822510&timestamp=1331161200&key=YOUR_API_KEY

다음 Python 예시는 지수 백오프 요청 방법을 보여줍니다.

import json
import time
import urllib.error
import urllib.parse
import urllib.request

# The maps_key defined below isn't a valid Google Maps API key.
# You need to get your own API key.
# See https://developers.google.com/maps/documentation/timezone/get-api-key
API_KEY = "YOUR_KEY_HERE"
TIMEZONE_BASE_URL = "https://maps.googleapis.com/maps/api/timezone/json"

def timezone(lat, lng, timestamp):

# Join the parts of the URL together into one string.
params = urllib.parse.urlencode(
url = f"{TIMEZONE_BASE_URL}?{params}"

current_delay = 0.1  # Set the initial retry delay to 100ms.
max_delay = 5  # Set the maximum retry delay to 5 seconds.

while True:
try:
# Get the API response.
response = urllib.request.urlopen(url)
except urllib.error.URLError:
pass  # Fall through to the retry loop.
else:
# If we didn't get an IOError then parse the result.
result = json.load(response)

if result["status"] == "OK":
return result["timeZoneId"]
elif result["status"] != "UNKNOWN_ERROR":
# Many API errors cannot be fixed by a retry, e.g. INVALID_REQUEST or
# ZERO_RESULTS. There is no point retrying these requests.
raise Exception(result["error_message"])

if current_delay > max_delay:
raise Exception("Too many retry attempts.")

print("Waiting", current_delay, "seconds before retrying.")

time.sleep(current_delay)
current_delay *= 2  # Increase the delay each time we retry.

if __name__ == "__main__":
tz = timezone(39.6034810, -119.6822510, 1331161200)
print(f"Timezone: {tz}")

또한 애플리케이션 호출 체인 위에 요청이 빠르게 반복되는 재시도 코드가 없는지 확인해야 합니다.

동기화된 요청

Google API에 대한 동기화된 대량의 요청은 Google 인프라에 대한 분산형 서비스 거부 (DDoS) 공격처럼 보일 수 있으며, 이에 따라 처리될 수 있습니다. 이를 방지하려면 API 요청이 클라이언트 간에 동기화되지 않도록 해야 합니다.

예를 들어, 현재 시간대의 시간을 표시하는 애플리케이션을 생각해 봅시다.
이 애플리케이션은 표시된 시간이 업데이트될 수 있도록 분 시작 시 클라이언트 운영체제에서 알람을 설정할 수 있습니다. 애플리케이션은 해당 알람과 관련된 처리의 일환으로 API를 호출해서는 안 됩니다.

고정된 알람에 응답하여 API를 호출하는 것은 좋지 않습니다. 시간이 지남에 따라 균등하게 분산되는 대신 API 호출이 여러 기기 간에 분 시작 시점에 동기화되기 때문입니다. 이렇게 설계된 애플리케이션은 매분마다 시작 시 정상 수준의 60배에 달하는 트래픽이 급증합니다.

이 문제를 해결하려면 두 번째 알람을 임의로 선택한 시간으로 설정하도록 설계하면 됩니다.
이 두 번째 알람이 발생하면 애플리케이션은 필요한 API를 호출하고 결과를 저장합니다.  애플리케이션이 분 시작 시 디스플레이를 업데이트하려고 하면 API를 다시 호출하는 대신 이전에 저장된 결과를 사용합니다. 이 접근 방식을 사용하면 API 호출이 시간 경과에 따라 균등하게 분산됩니다. 또한 API 호출은 디스플레이가 업데이트될 때 렌더링을 지연시키지 않습니다.

분 시작 시간 외에도 주의해서 타겟팅하지 않아야 하는 다른 일반적인 동기화 시간은 시간 시작 시간과 자정에 시작하는 각 날짜입니다.

응답 처리

참고: 웹 서비스 요청과 함께 제공되는 개별 응답의 정확한 형식은 보장되지 않으므로 (일부 요소가 누락되거나 여러 위치에 있을 수 있음) 특정 응답에 대해 반환된 형식이 다른 쿼리에서 동일하다고 가정해서는 안 됩니다. 대신 응답을 처리하고 표현식을 통해 적절한 값을 선택해야 합니다.

이 섹션에서는 웹 서비스 응답에서 이들 값을 동적으로 추출하는 방법에 대해 설명합니다.

Google 지도 웹 서비스는 이해하기 쉽지만 사용자 친화적이지 않은 응답을 제공합니다. 쿼리를 실행할 때는 데이터 세트를 표시하는 대신 몇 가지 특정 값을 추출하는 것이 좋습니다. 일반적으로 웹 서비스의 응답을 파싱하고 관심 있는 값만 추출하는 것이 좋습니다.

사용하는 파싱 스키마는 XML 또는 JSON으로 출력을 반환하는지에 따라 다릅니다. 이미 JavaScript 객체 형식인 JSON 응답은 클라이언트의 JavaScript 자체 내에서 처리될 수 있습니다.

XML 응답은 XML 프로세서와 XML 쿼리 언어를 사용하여 처리하여 XML 형식 내의 요소를 처리해야 합니다.
다음 예에서는 XML 처리 라이브러리에서 일반적으로 지원되는 XPath [https://www.w3.org/TR/xpath/]를 사용합니다.

XPath로 XML 처리

XML은 데이터 교환에 사용되는 비교적 성숙한 구조화된 정보 형식입니다. JSON만큼 가볍지는 않지만 XML은 더 많은 언어 지원과 더 강력한 도구를 제공합니다. 예를 들어 Java에서 XML을 처리하는 코드는 javax.xml 패키지에 빌드됩니다.

XML 응답을 처리할 때는 요소가 XML 마크업 내 절대 위치에 있다고 가정하는 대신 XML 문서 내에서 노드를 선택하는 데 적절한 쿼리 언어를 사용해야 합니다. XPath [https://en.wikipedia.org/wiki/XPath]는 XML 문서 내의 노드와 요소를 고유하게 설명하기 위한 언어 문법입니다. XPath 표현식을 사용하면 XML 응답 문서 내에서 특정 콘텐츠를 식별할 수 있습니다.

XPath 식

XPath에 대한 지식을 어느 정도 갖추면 강력한 파싱 스키마를 개발하는 데 큰 도움이 됩니다. 이 섹션에서는 XML 문서 내의 요소가 XPath로 처리되는 방식을 중점적으로 다룹니다. 이를 통해 여러 요소를 처리하고 복잡한 쿼리를 구성할 수 있습니다.

XPath는 디렉터리 경로에 사용되는 것과 유사한 문법을 사용하여 표현식을 사용하여 XML 문서 내에서 요소를 선택합니다.
이러한 표현식은 DOM과 유사한 계층 구조 트리인 XML 문서 트리 내의 요소를 식별합니다.
일반적으로 XPath 표현식은 제공된 기준과 일치하는 모든 노드와 일치함을 나타내는 탐욕스러운 표현식입니다.

다음 추상 XML을 사용하여 예를 설명하겠습니다.

<WebServiceResponse>
<status>OK</status>
<result>
<type>sample</type>
<name>Sample XML</name>
<location>
<lat>37.4217550</lat>
<lng>-122.0846330</lng>
</location>
</result>
<result>
<message>The secret message</message>
</result>
</WebServiceResponse>

식에서 노드 선택

XPath 선택은 노드를 선택합니다. 루트 노드는 전체 문서를 포함합니다. 이 노드는 특수 표현식 '/'를 사용하여 선택합니다. 루트 노드는 XML 문서의 최상위 노드가 아닙니다. 실제로 이 최상위 요소 위에 한 수준에 있으며 이 요소를 포함합니다.

요소 노드는 XML 문서 트리 내의 다양한 요소를 나타냅니다. 예를 들어 <WebServiceResponse> 요소는 위의 샘플 서비스에서 반환된 최상위 요소를 나타냅니다. 개별 노드는 선행 '/' 문자의 유무로 표시되는 절대 경로 또는 상대 경로를 통해 선택합니다.

절대 경로: '/WebServiceResponse/result' 표현식은 <WebServiceResponse> 노드의 하위 요소인 모든 <result> 노드를 선택합니다. 이 두 요소는 모두 루트 노드 '/'에서 상속됩니다.
현재 컨텍스트의 상대 경로: 'result' 표현식은 현재 컨텍스트 내의 모든 <result> 요소와 일치합니다. 일반적으로 단일 표현식을 통해 웹 서비스 결과를 처리하므로 컨텍스트에 관해 걱정할 필요가 없습니다.

이 표현식 중 하나는 와일드 카드 경로를 추가하여 확장할 수 있으며, 이는 이중 슬래시 ('//')로 표시됩니다. 이 와일드 카드는 중간에 있는 경로에서 0개 이상의 요소가 일치할 수 있음을 나타냅니다. 예를 들어 XPath 표현식 '//formatted_address'은 현재 문서에서 해당 이름의 모든 노드와 일치합니다.
표현식 //viewport//lat는 <viewport>를 상위 요소로 추적할 수 있는 모든 <lat> 요소와 일치합니다.

기본적으로 XPath 식은 모든 요소를 비교합니다. 특정 요소와 일치하도록 표현식을 제한하려면 대괄호 ([])로 묶인 조건자를 제공하면 됩니다. 예를 들어 XPath 표현식 '/GeocodeResponse/result[2]은 항상 두 번째 결과를 반환합니다.

| 식의 유형 |
| --- |
| 루트 노드 | XPath 표현식:  "/" 선택:     <WebServiceResponse>      <status>OK</status>      <result>       <type>sample</type>       <name>Sample XML</name>       <location>        <lat>37.4217550</lat>        <lng>-122.0846330</lng>       </location>      </result>      <result>       <message>The secret message</message>      </result>     </WebServiceResponse> |
| 절대 경로 | XPath 표현식:  "/WebServiceResponse/result" 선택:     <result>      <type>sample</type>      <name>Sample XML</name>      <location>       <lat>37.4217550</lat>       <lng>-122.0846330</lng>      </location>     </result>     <result>      <message>The secret message</message>     </result> |
| 와일드카드가 있는 경로 | XPath 표현식:  "/WebServiceResponse//location" 선택:     <location>      <lat>37.4217550</lat>      <lng>-122.0846330</lng>     </location> |
| 조건자가 있는 경로 | XPath 표현식:  "/WebServiceResponse/result[2]/message" 선택:     <message>The secret message</message> |
| 첫 번째 result의 모든 직접 하위 요소 | XPath 표현식:  "/WebServiceResponse/result[1]/*" 선택:      <type>sample</type>      <name>Sample XML</name>      <location>       <lat>37.4217550</lat>       <lng>-122.0846330</lng>      </location> |
| type 텍스트가 'sample'인 result의 name입니다. | XPath 표현식:  "/WebServiceResponse/result[type/text()='sample']/name" 선택:     Sample XML |

요소를 선택할 때는 객체 내의 텍스트뿐만 아니라 노드를 선택해야 합니다. 일반적으로 일치하는 모든 노드를 반복하고 텍스트를 추출해야 합니다. 텍스트 노드를 직접 일치시킬 수도 있습니다. 아래의 텍스트 노드 [https://developers.google.com/maps/documentation/geocoding/web-service-best-practices?hl=ko#Text]를 참고하세요.

XPath는 속성 노드도 지원합니다. 그러나 모든 Google 지도 웹 서비스는 속성이 없는 요소를 제공하므로 속성을 일치시킬 필요가 없습니다.

식에서 텍스트 선택

XML 문서 내 텍스트는 텍스트 노드 연산자를 통해 XPath 표현식에 지정됩니다. 이 연산자 'text()'은 지정된 노드에서 텍스트를 추출함을 나타냅니다. 예를 들어 XPath 표현식 '//formatted_address/text()'은 <formatted_address> 요소 내의 모든 텍스트를 반환합니다.

| 식의 유형 |
| --- |
| 모든 텍스트 노드(공백 포함) | XPath 표현식:  "//text()" 선택:     sample     Sample XML      37.4217550     -122.0846330     The secret message |
| 텍스트 선택 | XPath 표현식:  "/WebServiceRequest/result[2]/message/text()" 선택:     The secret message |
| 컨텍스트에 따른 선택 | XPath 표현식:  "/WebServiceRequest/result[type/text() = 'sample']/name/text()" 선택:     Sample XML |

또는 표현식을 평가하여 노드 집합을 반환한 다음 이 '노드 집합'을 반복하여 각 노드에서 텍스트를 추출할 수 있습니다. 아래 예시에서는 이 방법을 사용합니다.

XPath에 관한 자세한 내용은 XPath W3C 사양 [http://www.w3.org/TR/xpath/]을 참고하세요.

Java에서 XPath 평가

Java는 XML 파싱 및 javax.xml.xpath.* 패키지 내에서 XPath 표현식 사용을 광범위하게 지원합니다.
따라서 이 섹션의 샘플 코드는 Java를 사용하여 XML을 처리하고 XML 서비스 응답에서 데이터를 파싱하는 방법을 보여줍니다.

Java 코드에서 XPath를 사용하려면 먼저 XPathFactory 인스턴스를 인스턴스화하고 이 팩토리에서 newXPath()를 호출하여 XPath
객체를 만들어야 합니다. 그러면 이 객체는 evaluate() 메서드를 사용하여 전달된 XML 및 XPath 표현식을 처리할 수 있습니다.

XPath 표현식을 평가할 때는 반환될 수 있는 모든 '노드 세트'를 반복해야 합니다. 이러한 결과는 Java 코드에서 DOM 노드로 반환되므로 NodeList 객체 내에 이러한 여러 값을 캡처하고 해당 객체를 반복하여 이러한 노드에서 텍스트나 값을 추출해야 합니다.

다음 코드는 XPath 객체를 만들고 XML 및 XPath 표현식을 할당한 후 표현식을 평가하여 관련 콘텐츠를 출력하는 방법을 보여줍니다.

import org.xml.sax.InputSource;
import org.w3c.dom.*;
import javax.xml.xpath.*;
import java.io.*;

public class SimpleParser {

public static void main(String[] args) throws IOException {

XPathFactory factory = XPathFactory.newInstance();

XPath xpath = factory.newXPath();

try {
System.out.print("Web Service Parser 1.0\n");

File xmlFile = new File("XML_FILE");

InputSource inputXml = new InputSource(new FileInputStream(xmlFile));

NodeList nodes = (NodeList) xpath.evaluate("XPATH_EXPRESSION", inputXml, XPathConstants.NODESET);

String nodeString = nodes.item(i).getTextContent();
System.out.print(nodeString);
System.out.print("\n");
System.out.print("XPath Error");
System.out.print("File Error");