Source URL: https://developers.google.com/maps/documentation/navigation/android-sdk/controls?hl=ko
Title: 탐색 UI 수정

의견 보내기

탐색 UI 수정

컬렉션을 사용해 정리하기

내 환경설정을 기준으로 콘텐츠를 저장하고 분류하세요.

Android용 Navigation SDK를 사용하면 지도에 표시되는 기본 제공 UI 컨트롤과 요소를 지정하여 지도의 사용자 환경을 수정할 수 있습니다. 탐색 UI의 시각적 모양을 조정할 수도 있습니다. 탐색 UI의 허용되는 수정사항에 관한 가이드라인은 정책 페이지 [https://developers.google.com/maps/documentation/navigation/android-sdk/policies?hl=ko]를 참고하세요.

이 문서에서는 다음과 같은 두 가지 방법으로 지도의 사용자 인터페이스를 수정하는 방법을 설명합니다.

지도 UI 컨트롤 [https://developers.google.com/maps/documentation/navigation/android-sdk/controls?hl=ko#map_ui_controls]
지도 UI 액세서리 [https://developers.google.com/maps/documentation/navigation/android-sdk/controls?hl=ko#map_ui_accessories]

참고: 대부분의 경우 NavigationView과 직접 상호작용하는 대신 NavigationView [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/NavigationView?hl=ko]의 래퍼인 SupportNavigationFragment [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/SupportNavigationFragment?hl=ko]를 사용하는 것이 좋습니다. 자세한 내용은 탐색 지도 상호작용 권장사항 [https://developers.google.com/maps/documentation/navigation/android-sdk/nav-map-interactions-best-practices?hl=ko]을 참고하세요.주의: Android Navigation SDK는 지도 ID를 사용한 클라우드 기반 지도 스타일 지정을 지원하지 않습니다.
지도 UI 컨트롤

탐색 뷰에 맞춤 UI 요소를 배치하려면 적절한 위치 지정을 위해 지도 UI 컨트롤을 사용하세요. 내장 레이아웃이 변경되면 Android용 Navigation SDK가 맞춤 컨트롤의 위치를 자동으로 변경합니다.
각 위치에 대해 한 번에 하나의 맞춤 제어 뷰를 설정할 수 있습니다. 디자인에 여러 UI 요소가 필요한 경우 ViewGroup에 배치하고 setCustomControl 메서드에 전달하면 됩니다.

setCustomControl 메서드 [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/SupportNavigationFragment?hl=ko#setCustomControl]는 CustomControlPosition enum [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/CustomControlPosition?hl=ko]에 정의된 대로 위치를 제공합니다.

SECONDARY_HEADER (세로 모드로만 표시됨)
BOTTOM_START_BELOW
BOTTOM_END_BELOW
FOOTER

세로 모드의 맞춤 컨트롤 위치

가로 모드의 맞춤 컨트롤 위치

맞춤 컨트롤 추가

맞춤 UI 요소 또는 ViewGroup을 사용하여 Android View [https://developer.android.com/reference/android/view/View.html?hl=ko]를 만듭니다.
XML을 확장하거나 맞춤 뷰를 인스턴스화하여 뷰 인스턴스를 가져옵니다.
CustomControlPosition 열거형 [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/CustomControlPosition?hl=ko]에서 선택한 맞춤 컨트롤 위치와 함께 NavigationView.setCustomControl 또는 SupportNavigationFragment.setCustomControl를 사용합니다.
참고: 앱은 UI 스레드에서 이 메서드를 호출해야 합니다.
아래 예에서는 프래그먼트를 만들고 보조 헤더 위치에 맞춤 컨트롤을 추가합니다.
참고: 예의 코드에는 문서에서 잘 보이도록 줄바꿈이 있습니다. 적절하게 삭제해야 합니다. mNavFragment.setCustomControl(getLayoutInflater().
inflate(R.layout.your_custom_control, null),
CustomControlPosition.SECONDARY_HEADER);
```

맞춤 컨트롤 삭제

맞춤 컨트롤을 삭제하려면 null 뷰 매개변수와 선택한 맞춤 컨트롤 위치를 사용하여 setCustomControl 메서드를 호출합니다.

예를 들어 다음 스니펫은 맞춤 보조 헤더를 삭제하고 기본 콘텐츠로 돌아갑니다.
mNavFragment.setCustomControl(null, CustomControlPosition.SECONDARY_HEADER);

맞춤 컨트롤 위치

보조 헤더

세로 모드의 보조 헤더 맞춤 제어 위치

이 맞춤 컨트롤 위치를 사용하려면 위치 CustomControlPosition.SECONDARY_HEADER를 setCustomControl에 전달하세요.

기본적으로 탐색 모드의 화면 레이아웃은 기본 헤더 아래에 있는 보조 헤더의 위치를 제공합니다. 이 보조 헤더는 차선 안내와 같이 필요한 경우에 표시됩니다. 앱은 맞춤 콘텐츠에 레이아웃의 이 보조 헤더 위치를 사용할 수 있습니다. 이 기능을 사용하면 컨트롤이 기본 보조 헤더 콘텐츠를 포함합니다. 탐색 뷰에 배경이 있는 경우 배경은 그대로 유지되며 보조 헤더로 덮입니다.
앱에서 맞춤 컨트롤을 삭제하면 기본 보조 헤더가 대신 표시될 수 있습니다.

맞춤 보조 헤더 위치는 상단 가장자리를 기본 헤더의 하단 가장자리에 맞춥니다. 이 위치는 portrait mode에서만 지원됩니다. landscape mode에서는 보조 헤더를 사용할 수 없으며 레이아웃이 변경되지 않습니다.

하단 시작

세로 모드의 하단 시작 맞춤 제어 위치

가로 모드의 하단 시작 맞춤 제어 위치

이 맞춤 컨트롤 위치를 사용하려면 위치 CustomControlPosition.BOTTOM_START_BELOW를 setCustomControl에 전달하세요.

이 맞춤 컨트롤 위치는 지도의 하단 시작 모서리에 있습니다. portrait mode와 landscape mode 모두 ETA 카드 및/또는 맞춤 바닥글 위에 표시되며 (둘 다 없는 경우 지도 하단에 표시됨) 다시 가운데로 이동 버튼과 Google 로고를 비롯한 Nav SDK 요소가 맞춤 컨트롤 뷰의 높이를 고려하여 위로 이동합니다. 이 컨트롤은 표시되는 지도 경계 내에 배치되므로 지도의 하단 또는 시작 가장자리에 추가된 패딩도 이 컨트롤의 위치를 변경합니다.

하단 끝

세로 방향의 하단 맞춤 컨트롤 위치

가로 모드의 하단 맞춤 컨트롤 위치

이 맞춤 컨트롤 위치를 사용하려면 위치 CustomControlPosition.BOTTOM_END_BELOW를 setCustomControl에 전달하세요.

이 맞춤 컨트롤 위치는 지도의 하단 끝 모서리에 있습니다. portrait mode에서는 ETA 카드 또는 맞춤 바닥글 위에 배치되지만 (둘 다 없는 경우 지도 하단에 배치됨) landscape mode에서는 지도 하단에 정렬됩니다. 끝쪽에 표시되는 모든 Nav SDK 요소(LTR의 경우 오른쪽)는 맞춤 컨트롤 뷰의 높이를 고려하여 위로 이동합니다. 이 컨트롤은 표시되는 지도 경계 내에 배치되므로 지도의 하단 또는 끝에 추가된 패딩도 이 컨트롤의 위치를 변경합니다.

바닥글

미리보기 [https://developers.google.com/maps/launch-stages?hl=ko] 기능

세로 모드의 바닥글 맞춤 컨트롤 위치

가로 모드의 푸터 맞춤 컨트롤 위치

이 맞춤 컨트롤 위치를 사용하려면 위치 CustomControlPosition.FOOTER를 setCustomControl에 전달하세요.

이 맞춤 컨트롤 위치는 맞춤 바닥글 뷰를 위해 설계되었습니다. Nav SDK ETA 카드가 표시되면 이 컨트롤이 그 위에 표시됩니다. 그렇지 않으면 컨트롤이 지도의 하단에 맞춰 정렬됩니다. BOTTOM_START_BELOW 및 BOTTOM_END_BELOW 맞춤 컨트롤과 달리 이 컨트롤은 표시되는 지도 경계 외부에 배치되므로 지도에 추가된 패딩이 이 컨트롤의 위치를 변경하지 않습니다.

portrait mode에서 맞춤 바닥글은 전체 너비입니다. CustomControlPosition.BOTTOM_START_BELOW 및 CustomControlPosition.BOTTOM_END_BELOW 위치의 맞춤 컨트롤과 Nav SDK UI 요소(예: 다시 가운데로 버튼 및 Google 로고)는 맞춤 컨트롤 바닥글 위에 배치됩니다. 셰브론의 기본 위치는 맞춤 바닥글 높이를 고려합니다.

landscape mode에서 맞춤 바닥글은 Nav SDK 예상 도착 시간 카드와 마찬가지로 너비가 절반이고 시작 측면 (LTR의 경우 왼쪽)에 정렬됩니다. CustomControlPosition.BOTTOM_START_BELOW 위치의 맞춤 컨트롤과 다시 가운데로 버튼, Google 로고와 같은 Nav SDK UI 요소는 맞춤 컨트롤 바닥글 위에 배치됩니다. CustomControlPosition.BOTTOM_END_BELOW 위치의 맞춤 컨트롤과 끝쪽 (LTR의 경우 오른쪽)에 있는 Nav SDK UI 요소는 지도의 하단에 맞춰 정렬됩니다. 맞춤 바닥글은 지도의 끝까지 확장되지 않으므로 맞춤 바닥글이 있으면 셰브론의 기본 위치가 변경되지 않습니다.

CustomControlPosition.BOTTOM_START_BELOW 및 CustomControlPosition.BOTTOM_END_BELOW 위치의 맞춤 컨트롤과 다시 가운데로 이동 버튼, Google 로고와 같은 Nav SDK UI 요소는 맞춤 컨트롤 바닥글 위에 배치됩니다.

지도 UI 액세서리

Android용 Navigation SDK는 Android용 Google 지도 애플리케이션에 있는 것과 유사한 탐색 중에 표시되는 UI 액세서리를 제공합니다.
이 섹션에 설명된 대로 이러한 컨트롤의 공개 상태 또는 시각적 모양을 조정할 수 있습니다. 여기에서 변경한 사항은 다음 탐색 세션에 반영됩니다.

탐색 UI의 허용되는 수정사항에 관한 가이드라인은 정책 페이지 [https://developers.google.com/maps/documentation/navigation/android-sdk/policies?hl=ko]를 참고하세요.

코드 보기

탐색 활동의 Java 코드를 표시하거나 숨깁니다.

package com.example.navsdkcustomization;

import android.content.pm.PackageManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Bundle;
import android.util.Log;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import com.google.android.gms.maps.GoogleMap;
import com.google.android.gms.maps.GoogleMap.CameraPerspective;
import com.google.android.gms.maps.OnMapReadyCallback;
import com.google.android.gms.maps.model.BitmapDescriptorFactory;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.Marker;
import com.google.android.gms.maps.model.MarkerOptions;
import com.google.android.libraries.navigation.ListenableResultFuture;
import com.google.android.libraries.navigation.NavigationApi;
import com.google.android.libraries.navigation.Navigator;
import com.google.android.libraries.navigation.SimulationOptions;
import com.google.android.libraries.navigation.StylingOptions;
import com.google.android.libraries.navigation.SupportNavigationFragment;
import com.google.android.libraries.navigation.Waypoint;

private Navigator mNavigator;
private SupportNavigationFragment mNavFragment;
private GoogleMap mMap;
private boolean mLocationPermissionGranted;

@Override
protected void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
setContentView(R.layout.activity_main);

this.getApplicationContext(), android.Manifest.permission.ACCESS_FINE_LOCATION)
== PackageManager.PERMISSION_GRANTED) {
mLocationPermissionGranted = true;
ActivityCompat.requestPermissions(
this,
new String[] {android.Manifest.permission.ACCESS_FINE_LOCATION},
PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION);
"Error loading Navigation SDK: " + "The user has not granted location permission.");
return;
NavigationApi.getNavigator(
this,
new NavigationApi.NavigatorListener() {
mNavigator = navigator;
mNavFragment =
(SupportNavigationFragment)
getSupportFragmentManager().findFragmentById(R.id.navigation_fragment);

new OnMapReadyCallback() {
@Override
public void onMapReady(GoogleMap map) {
mMap = map;
"Error loading Navigation SDK: Your API key is "
+ "invalid or not authorized to use the Navigation SDK.");
break;
case NavigationApi.ErrorCode.TERMS_NOT_ACCEPTED:
displayMessage(
"Error loading Navigation SDK: User did not accept "
+ "the Navigation Terms of Use.");
break;
case NavigationApi.ErrorCode.NETWORK_ERROR:
displayMessage("Error loading Navigation SDK: Network error.");
break;
case NavigationApi.ErrorCode.LOCATION_PERMISSION_MISSING:
displayMessage(
"Error loading Navigation SDK: Location permission " + "is missing.");
break;
default:
displayMessage("Error loading Navigation SDK: " + errorCode);
new StylingOptions()
.primaryDayModeThemeColor(0xff1A237E)
.secondaryDayModeThemeColor(0xff3F51B5)
.primaryNightModeThemeColor(0xff212121)
.secondaryNightModeThemeColor(0xff424242)
.headerLargeManeuverIconColor(0xffffff00)
.headerSmallManeuverIconColor(0xffffa500)
.headerNextStepTypefacePath("/system/fonts/NotoSerif-BoldItalic.ttf")
.headerNextStepTextColor(0xff00ff00)
.headerNextStepTextSize(20f)
.headerDistanceTypefacePath("/system/fonts/NotoSerif-Italic.ttf")
.headerDistanceValueTextColor(0xff00ff00)
.headerDistanceUnitsTextColor(0xff0000ff)
.headerDistanceValueTextSize(20f)
.headerDistanceUnitsTextSize(18f)
.headerInstructionsTypefacePath("/system/fonts/NotoSerif-BoldItalic.ttf")
.headerInstructionsTextColor(0xffffff00)
.headerInstructionsFirstRowTextSize(24f)
.headerInstructionsSecondRowTextSize(20f)
.headerGuidanceRecommendedLaneColor(0xffffa500));

mMap.setTrafficEnabled(false);

LatLng destinationLatLng = mNavigator.getCurrentRouteSegment().getDestinationLatLng();

Bitmap destinationMarkerIcon =
BitmapFactory.decodeResource(getResources(), R.drawable.ic_person_pin_48dp);

mMap.addMarker(
new MarkerOptions()
.position(destinationLatLng)
.icon(BitmapDescriptorFactory.fromBitmap(destinationMarkerIcon))
.title("Destination marker"));

new GoogleMap.OnMarkerClickListener() {
@Override
public boolean onMarkerClick(Marker marker) {
displayMessage(
"Marker tapped: "
+ marker.getTitle()
+ ", at location "
+ marker.getPosition().latitude
+ ", "
+ marker.getPosition().longitude);

Waypoint destination;
try {
destination =
Waypoint.builder().setPlaceIdString(placeId).build();
return;
ListenableResultFuture<Navigator.RouteStatus> pendingRoute =
mNavigator.setDestination(destination);

new ListenableResultFuture.OnResultListener<Navigator.RouteStatus>() {
@Override
public void onResult(Navigator.RouteStatus code) {
switch (code) {
case OK:

.getSimulator()
.simulateLocationsAlongExistingRoute(
new SimulationOptions().speedMultiplier(5));
break;
break;
case NETWORK_ERROR:
displayMessage("Error starting navigation: Network error.");
break;
case ROUTE_CANCELED:
displayMessage("Error starting navigation: Route canceled.");
break;
default:
displayMessage("Error starting navigation: " + String.valueOf(code));
int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
mLocationPermissionGranted = false;
switch (requestCode) {
case PERMISSIONS_REQUEST_ACCESS_FINE_LOCATION:
Toast.makeText(this, errorMessage, Toast.LENGTH_LONG).show();
Log.d(TAG, errorMessage);
mNavFragment = (SupportNavigationFragment) getFragmentManager()
.findFragmentById(R.id.navigation_fragment);

.primaryDayModeThemeColor(0xff1A237E)
.secondaryDayModeThemeColor(0xff3F51B5)
.primaryNightModeThemeColor(0xff212121)
.secondaryNightModeThemeColor(0xff424242)
.headerLargeManeuverIconColor(0xffffff00)
.headerSmallManeuverIconColor(0xffffa500)
.headerNextStepTypefacePath("/system/fonts/NotoSerif-BoldItalic.ttf")
.headerNextStepTextColor(0xff00ff00)
.headerNextStepTextSize(20f)
.headerDistanceTypefacePath("/system/fonts/NotoSerif-Italic.ttf")
.headerDistanceValueTextColor(0xff00ff00)
.headerDistanceUnitsTextColor(0xff0000ff)
.headerDistanceValueTextSize(20f)
.headerDistanceUnitsTextSize(18f)
.headerInstructionsTypefacePath("/system/fonts/NotoSerif-BoldItalic.ttf")
.headerInstructionsTextColor(0xffffff00)
.headerInstructionsFirstRowTextSize(24f)
.headerInstructionsSecondRowTextSize(20f)
.headerGuidanceRecommendedLaneColor(0xffffa500));

교통정보 레이어 사용 중지

GoogleMap.setTrafficEnabled() [https://developers.google.com/maps/documentation/android-sdk/reference/com/google/android/libraries/maps/GoogleMap?hl=ko#setTrafficEnabled(boolean)]를 사용하여 지도에서 교통 레이어를 사용 설정하거나 사용 중지합니다. 이 설정은 지도 전체에 표시되는 교통 밀도 표시에 영향을 미칩니다. 하지만 내비게이터에서 표시한 경로의 교통 상황 표시에는 영향을 미치지 않습니다.
private GoogleMap mMap;

신호등 및 정지 표지판 사용 설정

내비게이션이 활성 상태일 때 지도에 신호등과 정지 표지판을 표시할 수 있어 경로와 이동 조작에 관한 추가 컨텍스트를 제공합니다.

기본적으로 Navigation SDK에서는 신호등과 정지 표지판이 사용 중지되어 있습니다. 이 기능을 사용 설정하려면 각 기능에 대해 독립적으로 DisplayOptions [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/DisplayOptions?hl=ko]를 호출하세요.
참고: 내비게이션 모드가 아닌 경우에도 지도에 신호등이 표시될 수 있습니다. DisplayOptions를 사용하여 신호등 표시를 구성하는 옵션은 활성 탐색 모드의 신호등에만 영향을 미칩니다.DisplayOptions displayOptions =
new DisplayOptions().showTrafficLights(true).showStopSigns(true);

맞춤 마커 추가

이제 Android용 Navigation SDK에서 마커에 Google Maps API를 사용합니다. 자세한 내용은 Maps API 문서 [https://developers.google.com/maps/documentation/android-sdk/marker?hl=ko]를 참고하세요.

플로팅 텍스트

Google 저작자 표시를 가리지 않는다면 앱의 어느 곳에나 플로팅 텍스트를 추가할 수 있습니다. Navigation SDK는 지도상의 위도/경도 또는 라벨에 텍스트를 고정하는 기능을 지원하지 않습니다. 자세한 내용은 정보 창 [https://developers.google.com/maps/documentation/android-sdk/infowindows?hl=ko]을 참고하세요.

속도 제한 표시

속도 제한 아이콘을 프로그래매틱 방식으로 표시하거나 숨길 수 있습니다. NavigationView.setSpeedLimitIconEnabled() [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/NavigationView?hl=ko#setSpeedLimitIconEnabled(boolean)] 또는 SupportNavigationFragment.setSpeedLimitIconEnabled() [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/SupportNavigationFragment?hl=ko#setSpeedLimitIconEnabled(boolean)]을 사용하여 속도 제한 아이콘을 표시하거나 숨깁니다. 사용 설정하면 안내 중에 하단 모서리에 제한 속도 아이콘이 표시됩니다. 아이콘은 차량이 주행 중인 도로의 제한 속도를 표시합니다. 이 아이콘은 신뢰할 수 있는 속도 제한 데이터를 사용할 수 있는 위치에만 표시됩니다.

최근 위치로 이동 버튼이 표시되면 속도 제한 아이콘이 일시적으로 숨겨집니다.
참고: 사용자는 도로에 게시된 모든 표지판을 따라야 합니다. 속도 제한 아이콘에 게시된 데이터는 참고용으로만 사용됩니다. 제한속도 데이터의 정확성은 보장되지 않습니다. Google Cloud 지원 페이지 [https://console.cloud.google.com/google/maps-apis/support?hl=ko]에서 케이스를 제출하여 속도 제한 데이터의 부정확성을 신고할 수 있습니다.
야간 모드 설정

프로그래매틱 방식으로 야간 모드의 동작을 제어할 수 있습니다. NavigationView.setForceNightMode() [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/NavigationView?hl=ko#setForceNightMode(int)] 또는 SupportNavigationFragment.setForceNightMode() [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/SupportNavigationFragment?hl=ko#setForceNightMode(int)]를 사용하여 야간 모드를 사용 설정 또는 사용 중지하거나 Android용 Navigation SDK에서 제어하도록 합니다.

AUTO 탐색 SDK가 기기 위치와 현지 시간에 따라 적절한 모드를 결정하도록 합니다.
FORCE_NIGHT는 야간 모드를 강제로 사용 설정합니다.
FORCE_DAY는 주간 모드를 강제합니다.

다음 예는 탐색 프래그먼트 내에서 야간 모드를 강제로 사용 설정하는 방법을 보여줍니다.

경로 목록 표시

먼저 뷰를 만들고 계층 구조에 추가합니다.
void setupDirectionsListView() {
DirectionsListView directionsListView = new DirectionsListView(getApplicationContext());
ViewGroup group = findViewById(R.id.directions_view);
group.addView(directionsListView);

ImageButton button = findViewById(R.id.close_directions_button); // this button is part of the container we hide in the next line.
button.setOnClickListener(
v -> findViewById(R.id.directions_view_container).setVisibility(View.GONE));
NavigationView에서와 마찬가지로 수명 주기 이벤트를 DirectionsListView에 전달해야 합니다. 예를 들면 다음과 같습니다.
protected void onResume() {
super.onResume();
directionsListView.onResume();
RoutingOptions routingOptions = new RoutingOptions();
routingOptions.alternateRoutesStrategy(AlternateRoutesStrategy.SHOW_NONE);
navigator.setDestinations(destinations, routingOptions, displayOptions);

여행 진행률 표시줄

실험용 [https://developers.google.com/maps/launch-stages?hl=ko] 기능

이동 진행률 표시줄은 내비게이션이 시작될 때 지도의 시작/선두 측면에 표시되는 세로 막대입니다. 사용 설정하면 사용자의 목적지와 현재 위치와 함께 전체 여정의 개요가 표시됩니다.

이를 통해 사용자는 확대하지 않고도 트래픽과 같은 향후 문제를 빠르게 예측할 수 있습니다. 그런 다음 필요한 경우 이동 경로를 다시 지정할 수 있습니다. 사용자가 여정을 다시 설정하면 해당 지점에서 새 여정이 시작된 것처럼 진행률 표시줄이 재설정됩니다.

여정 진행률 표시줄에는 다음 상태 표시기가 표시됩니다.

경로 경과: 이동 중 경과된 부분입니다.
현재 위치: 여행 중 사용자의 현재 위치입니다.
교통 상황: 예정된 교통 상황입니다.
최종 목적지: 최종 여행 목적지입니다.

NavigationView [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/NavigationView?hl=ko#setTripProgressBarEnabled(boolean)] 또는 SupportNavigationFragment [https://developers.google.com/maps/documentation/navigation/android-sdk/reference/com/google/android/libraries/navigation/SupportNavigationFragment?hl=ko#setTripProgressBarEnabled(boolean)]에서 setTripProgressBarEnabled() 메서드를 호출하여 여정 진행률 표시줄을 사용 설정합니다.
예를 들면 다음과 같습니다.

여행 진행률 표시줄 위치

막대의 왼쪽은 속도계, Google 로고, 다시 가운데로 버튼 (표시되는 경우)의 왼쪽과 대략적으로 정렬됩니다. 너비는 12dp입니다.
여행 진행률 표시줄은 정적 높이를 유지합니다. 소형 기기의 세로 공간 제한에 적응하기 위해 여행 진행률 표시줄의 표시 여부와 높이는 화면 높이에 지정된 중단점에 따라 조정됩니다. 이러한 중단점은 기기 방향과 지도가 화면에서 실제로 차지하는 공간과 무관합니다.

| 화면 높이 | 이동 진행률 표시줄 표시 여부 | 여행 진행률 표시줄 높이 | 여행 진행률 표시줄 y축 위치 |
| --- | --- | --- | --- |
| 소형: 0dp~551dp | 표시 안 됨 | 해당 사항 없음 | 해당 사항 없음 |
| 중간: 552dp~739dp | 표시 | 130 dp | 시작 측면 컨트롤 위 (속도계 / Google 로고 / 다시 가운데로 버튼) |
| 대형: 740dp 이상 | 표시 | 290 dp | 시작 측면 컨트롤 위 (속도계 / Google 로고 / 다시 가운데로 버튼) |

참고: 위의 표에 표시된 화면 높이 값은 Navigation SDK 버전 6.2.1 이상에 적용됩니다. 버전 6.2.0의 경우 소형 화면은 0dp~519dp, 중형 화면은 520dp~599dp, 대형 화면은 600dp 이상으로 정의됩니다. 여행 진행률 표시줄의 표시 여부,    높이, y축 위치는 동일합니다.

이동 진행률 표시줄이 회전 카드 또는 기타 탐색 UI 요소와 겹치는 경우 다른 요소 아래에 표시됩니다.

프롬프트 표시 API (실험적)

실험용 [https://developers.google.com/maps/launch-stages?hl=ko] 기능

프롬프트 표시 상태 API를 사용하면 탐색 SDK에서 생성된 UI 요소와 자체 맞춤 UI 요소 간의 충돌을 방지할 수 있습니다. 탐색 SDK UI 요소가 표시되기 직전과 요소가 삭제되는 즉시 콜백을 수신하는 리스너를 추가하면 됩니다. 코드 샘플을 비롯한 자세한 내용은 실시간 교통 혼잡 구성 페이지의 프롬프트 표시 API [https://developers.google.com/maps/documentation/navigation/android-sdk/real-time-disruptions?hl=ko#prompt-visibility-api] 섹션을 참고하세요.

의견 보내기